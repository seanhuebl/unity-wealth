// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: transactions.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/seanhuebl/unity-wealth/internal/models"
)

const createTransaction = `-- name: CreateTransaction :exec
INSERT INTO
    transactions (
        id,
        user_id,
        transaction_date,
        merchant,
        amount_cents,
        detailed_category_id
    )
VALUES
    ($1, $2, $3, $4, $5, $6)
`

type CreateTransactionParams struct {
	ID                 uuid.UUID
	UserID             uuid.UUID
	TransactionDate    time.Time
	Merchant           string
	AmountCents        int64
	DetailedCategoryID int32
}

func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) error {
	_, err := q.db.ExecContext(ctx, createTransaction,
		arg.ID,
		arg.UserID,
		arg.TransactionDate,
		arg.Merchant,
		arg.AmountCents,
		arg.DetailedCategoryID,
	)
	return err
}

const deleteTransactionByID = `-- name: DeleteTransactionByID :execresult
DELETE FROM transactions
WHERE
    id = $1
    AND user_id = $2
`

type DeleteTransactionByIDParams struct {
	ID     uuid.UUID
	UserID uuid.UUID
}

func (q *Queries) DeleteTransactionByID(ctx context.Context, arg DeleteTransactionByIDParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, deleteTransactionByID, arg.ID, arg.UserID)
}

const getDetailedCategories = `-- name: GetDetailedCategories :many
SELECT
    id, name, description, primary_category_id
FROM
    detailed_categories
`

func (q *Queries) GetDetailedCategories(ctx context.Context) ([]models.DetailedCategory, error) {
	rows, err := q.db.QueryContext(ctx, getDetailedCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []models.DetailedCategory
	for rows.Next() {
		var i models.DetailedCategory
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.PrimaryCategoryID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDetailedCategoryID = `-- name: GetDetailedCategoryID :one
SELECT
    id
FROM
    detailed_categories
WHERE
    name = $1
`

func (q *Queries) GetDetailedCategoryID(ctx context.Context, name string) (int32, error) {
	row := q.db.QueryRowContext(ctx, getDetailedCategoryID, name)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const getPrimaryCategories = `-- name: GetPrimaryCategories :many
SELECT
    id, name
FROM
    primary_categories
`

func (q *Queries) GetPrimaryCategories(ctx context.Context) ([]models.PrimaryCategory, error) {
	rows, err := q.db.QueryContext(ctx, getPrimaryCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []models.PrimaryCategory
	for rows.Next() {
		var i models.PrimaryCategory
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserTransactionByID = `-- name: GetUserTransactionByID :one
SELECT
    id,
    user_id,
    transaction_date,
    merchant,
    amount_cents,
    detailed_category_id
FROM
    transactions
WHERE
    user_id = $1
    AND id = $2
LIMIT
    1
`

type GetUserTransactionByIDParams struct {
	UserID uuid.UUID
	ID     uuid.UUID
}

type GetUserTransactionByIDRow struct {
	ID                 uuid.UUID
	UserID             uuid.UUID
	TransactionDate    time.Time
	Merchant           string
	AmountCents        int64
	DetailedCategoryID int32
}

func (q *Queries) GetUserTransactionByID(ctx context.Context, arg GetUserTransactionByIDParams) (GetUserTransactionByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getUserTransactionByID, arg.UserID, arg.ID)
	var i GetUserTransactionByIDRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TransactionDate,
		&i.Merchant,
		&i.AmountCents,
		&i.DetailedCategoryID,
	)
	return i, err
}

const getUserTransactionsFirstPage = `-- name: GetUserTransactionsFirstPage :many
SELECT
    id,
    user_id,
    transaction_date,
    merchant,
    amount_cents,
    detailed_category_id
FROM
    transactions
WHERE
    user_id = $1
ORDER BY
    transaction_date ASC,
    id ASC
LIMIT
    $2
`

type GetUserTransactionsFirstPageParams struct {
	UserID uuid.UUID
	Limit  int32
}

type GetUserTransactionsFirstPageRow struct {
	ID                 uuid.UUID
	UserID             uuid.UUID
	TransactionDate    time.Time
	Merchant           string
	AmountCents        int64
	DetailedCategoryID int32
}

func (q *Queries) GetUserTransactionsFirstPage(ctx context.Context, arg GetUserTransactionsFirstPageParams) ([]GetUserTransactionsFirstPageRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserTransactionsFirstPage, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserTransactionsFirstPageRow
	for rows.Next() {
		var i GetUserTransactionsFirstPageRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TransactionDate,
			&i.Merchant,
			&i.AmountCents,
			&i.DetailedCategoryID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserTransactionsPaginated = `-- name: GetUserTransactionsPaginated :many
SELECT
    id,
    user_id,
    transaction_date,
    merchant,
    amount_cents,
    detailed_category_id
FROM
    transactions
WHERE
    user_id = $1
    AND (
        transaction_date > $2
        OR (
            transaction_date = $2
            AND id < $3
        )
    )
ORDER BY
    transaction_date ASC,
    id ASC
LIMIT
    $4
`

type GetUserTransactionsPaginatedParams struct {
	UserID          uuid.UUID
	TransactionDate time.Time
	ID              uuid.UUID
	Limit           int32
}

type GetUserTransactionsPaginatedRow struct {
	ID                 uuid.UUID
	UserID             uuid.UUID
	TransactionDate    time.Time
	Merchant           string
	AmountCents        int64
	DetailedCategoryID int32
}

func (q *Queries) GetUserTransactionsPaginated(ctx context.Context, arg GetUserTransactionsPaginatedParams) ([]GetUserTransactionsPaginatedRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserTransactionsPaginated,
		arg.UserID,
		arg.TransactionDate,
		arg.ID,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserTransactionsPaginatedRow
	for rows.Next() {
		var i GetUserTransactionsPaginatedRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TransactionDate,
			&i.Merchant,
			&i.AmountCents,
			&i.DetailedCategoryID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTransactionByID = `-- name: UpdateTransactionByID :one
UPDATE transactions
SET
    transaction_date = $1,
    merchant = $2,
    amount_cents = $3,
    detailed_category_id = $4
WHERE
    id = $5
    AND user_id = $6
RETURNING
    id,
    transaction_date,
    merchant,
    amount_cents,
    detailed_category_id,
    updated_at
`

type UpdateTransactionByIDParams struct {
	TransactionDate    time.Time
	Merchant           string
	AmountCents        int64
	DetailedCategoryID int32
	ID                 uuid.UUID
	UserID             uuid.UUID
}

type UpdateTransactionByIDRow struct {
	ID                 uuid.UUID
	TransactionDate    time.Time
	Merchant           string
	AmountCents        int64
	DetailedCategoryID int32
	UpdatedAt          time.Time
}

func (q *Queries) UpdateTransactionByID(ctx context.Context, arg UpdateTransactionByIDParams) (UpdateTransactionByIDRow, error) {
	row := q.db.QueryRowContext(ctx, updateTransactionByID,
		arg.TransactionDate,
		arg.Merchant,
		arg.AmountCents,
		arg.DetailedCategoryID,
		arg.ID,
		arg.UserID,
	)
	var i UpdateTransactionByIDRow
	err := row.Scan(
		&i.ID,
		&i.TransactionDate,
		&i.Merchant,
		&i.AmountCents,
		&i.DetailedCategoryID,
		&i.UpdatedAt,
	)
	return i, err
}
